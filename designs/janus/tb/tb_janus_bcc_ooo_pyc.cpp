#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

#include <cpp/pyc_konata.hpp>
#include <cpp/pyc_tb.hpp>

// Generated by `pyc-compile --emit=cpp`.
#include "janus_bcc_ooo_pyc_gen.hpp"

using pyc::cpp::Testbench;
using pyc::cpp::Wire;

namespace {

constexpr std::uint64_t kBootPc = 0x0000'0000'0001'0000ull;
constexpr std::uint64_t kBootSp = 0x0000'0000'0002'0000ull;
constexpr std::uint64_t kDefaultMaxCycles = 400000;
constexpr std::uint64_t kExitPcStableCycles = 8;

static bool envFlag(const char *name) {
  const char *v = std::getenv(name);
  if (!v)
    return false;
  return !(v[0] == '0' && v[1] == '\0');
}

template <unsigned AddrWidth, unsigned DataWidth, std::size_t DepthBytes>
static bool loadMemh(pyc::cpp::pyc_byte_mem<AddrWidth, DataWidth, DepthBytes> &mem, const std::string &path) {
  std::ifstream f(path);
  if (!f.is_open()) {
    std::cerr << "ERROR: failed to open memh: " << path << "\n";
    return false;
  }

  std::uint64_t addr = 0;
  std::string tok;
  while (f >> tok) {
    if (tok.empty())
      continue;
    if (tok[0] == '@') {
      addr = std::stoull(tok.substr(1), nullptr, 16);
      continue;
    }
    unsigned v = std::stoul(tok, nullptr, 16) & 0xFFu;
    mem.pokeByte(static_cast<std::size_t>(addr), static_cast<std::uint8_t>(v));
    addr++;
  }
  return true;
}

static bool runPerfBenchmark(const char *memhPath, std::uint64_t bootPc, std::uint64_t repeats, std::uint64_t maxCyclesPerRun) {
  if (repeats == 0)
    repeats = 1;

  std::uint64_t totalCycles = 0;
  for (std::uint64_t rep = 0; rep < repeats; rep++) {
    pyc::gen::janus_bcc_ooo_pyc dut{};
    if (!loadMemh(dut.mem, memhPath))
      return false;

    dut.boot_pc = Wire<64>(bootPc);
    std::uint64_t bootSp = kBootSp;
    if (const char *env = std::getenv("PYC_BOOT_SP")) {
      bootSp = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
    }
    dut.boot_sp = Wire<64>(bootSp);

    Testbench<pyc::gen::janus_bcc_ooo_pyc> tb(dut);
    tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
    tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

    bool halted = false;
    for (std::uint64_t i = 0; i < maxCyclesPerRun; i++) {
      tb.runCyclesAuto(1);
      if (dut.halted.toBool()) {
        halted = true;
        break;
      }
    }
    if (!halted) {
      std::cerr << "FAIL perf: did not halt after " << std::dec << maxCyclesPerRun << " cycles on repeat " << rep << "\n";
      return false;
    }
    totalCycles += dut.cycles.value();
  }

  std::cout << "ok: perf (cycles=" << std::dec << totalCycles << " repeats=" << repeats << ")\n";
  return true;
}

static bool runProgram(const char *name, const char *memhPath, std::uint64_t bootPc, std::optional<std::uint32_t> expectedMem100,
                       std::optional<std::uint64_t> expectedA0) {
  pyc::gen::janus_bcc_ooo_pyc dut{};
  if (!loadMemh(dut.mem, memhPath))
    return false;

  dut.boot_pc = Wire<64>(bootPc);
  std::uint64_t bootSp = kBootSp;
  if (const char *env = std::getenv("PYC_BOOT_SP")) {
    bootSp = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }
  dut.boot_sp = Wire<64>(bootSp);

  Testbench<pyc::gen::janus_bcc_ooo_pyc> tb(dut);

  const bool trace_log = (std::getenv("PYC_TRACE") != nullptr);
  const bool trace_verbose = (std::getenv("PYC_TRACE_VERBOSE") != nullptr);
  const bool trace_vcd = (std::getenv("PYC_VCD") != nullptr);
  const bool trace_konata = envFlag("PYC_KONATA");
  const char *commit_trace_path = std::getenv("PYC_COMMIT_TRACE");
  std::filesystem::path out_dir{};
  if (trace_log || trace_vcd || trace_konata) {
    const char *trace_dir_env = std::getenv("PYC_TRACE_DIR");
    out_dir = trace_dir_env ? std::filesystem::path(trace_dir_env) : std::filesystem::path(".pycircuit_out/janus/janus_bcc_ooo_pyc");
    std::filesystem::create_directories(out_dir);

    if (trace_log) {
      tb.enableLog((out_dir / (std::string("tb_janus_bcc_ooo_pyc_cpp_") + name + ".log")).string());
      tb.log() << "tb_janus_bcc_ooo_pyc(C++): memh=" << memhPath << " boot_pc=0x" << std::hex << bootPc << std::dec << "\n";
    }

    if (trace_vcd) {
      tb.enableVcd((out_dir / (std::string("tb_janus_bcc_ooo_pyc_cpp_") + name + ".vcd")).string(), /*top=*/"tb_janus_bcc_ooo_pyc_cpp");
      tb.vcdTrace(dut.clk, "clk");
      tb.vcdTrace(dut.rst, "rst");
      tb.vcdTrace(dut.boot_pc, "boot_pc");
      tb.vcdTrace(dut.boot_sp, "boot_sp");
      tb.vcdTrace(dut.halted, "halted");
      tb.vcdTrace(dut.pc, "pc");
      tb.vcdTrace(dut.fpc, "fpc");
      tb.vcdTrace(dut.cycles, "cycles");
      tb.vcdTrace(dut.commit_fire, "commit_fire");
      tb.vcdTrace(dut.commit_op, "commit_op");
      tb.vcdTrace(dut.commit_value, "commit_value");
      tb.vcdTrace(dut.commit_dst_kind, "commit_dst_kind");
      tb.vcdTrace(dut.commit_dst_areg, "commit_dst_areg");
      tb.vcdTrace(dut.commit_pdst, "commit_pdst");
      tb.vcdTrace(dut.rob_count, "rob_count");
      tb.vcdTrace(dut.a0, "a0");
      tb.vcdTrace(dut.a1, "a1");
      tb.vcdTrace(dut.ra, "ra");
      tb.vcdTrace(dut.sp, "sp");
      tb.vcdTrace(dut.ct0, "ct0");
      tb.vcdTrace(dut.cu0, "cu0");
      tb.vcdTrace(dut.st0, "st0");
      tb.vcdTrace(dut.su0, "su0");
      tb.vcdTrace(dut.issue_fire, "issue_fire");
      tb.vcdTrace(dut.issue_op, "issue_op");
      tb.vcdTrace(dut.issue_pc, "issue_pc");
      tb.vcdTrace(dut.issue_rob, "issue_rob");
      tb.vcdTrace(dut.issue_sl, "issue_sl");
      tb.vcdTrace(dut.issue_sr, "issue_sr");
      tb.vcdTrace(dut.issue_sp, "issue_sp");
      tb.vcdTrace(dut.issue_pdst, "issue_pdst");
      tb.vcdTrace(dut.issue_sl_val, "issue_sl_val");
      tb.vcdTrace(dut.issue_sr_val, "issue_sr_val");
      tb.vcdTrace(dut.issue_sp_val, "issue_sp_val");
      tb.vcdTrace(dut.issue_is_load, "issue_is_load");
      tb.vcdTrace(dut.issue_is_store, "issue_is_store");
      tb.vcdTrace(dut.store_pending, "store_pending");
      tb.vcdTrace(dut.store_pending_older, "store_pending_older");
      tb.vcdTrace(dut.mem_raddr, "mem_raddr");
      tb.vcdTrace(dut.dispatch_fire, "dispatch_fire");
      tb.vcdTrace(dut.dec_op, "dec_op");
      tb.vcdTrace(dut.mmio_uart_valid, "mmio_uart_valid");
      tb.vcdTrace(dut.mmio_uart_data, "mmio_uart_data");
      tb.vcdTrace(dut.mmio_exit_valid, "mmio_exit_valid");
      tb.vcdTrace(dut.mmio_exit_code, "mmio_exit_code");
    }
  }

  std::ofstream commit_trace{};
  std::uint64_t commit_idx = 0;
  if (commit_trace_path && commit_trace_path[0] != '\0') {
    std::filesystem::path p(commit_trace_path);
    if (p.has_parent_path()) {
      std::filesystem::create_directories(p.parent_path());
    }
    commit_trace.open(p, std::ios::out | std::ios::trunc);
    if (!commit_trace.is_open()) {
      std::cerr << "WARN: failed to open commit trace output: " << p << "\n";
    }
  }

  auto maskInsn = [&](std::uint64_t raw, std::uint8_t len) -> std::uint64_t {
    switch (len) {
    case 2:
      return raw & 0xFFFFu;
    case 4:
      return raw & 0xFFFF'FFFFu;
    case 6:
      return raw & 0xFFFF'FFFF'FFFFu;
    default:
      return raw;
    }
  };

  auto emitCommit = [&](bool valid,
                        std::uint64_t pc,
                        std::uint64_t insn_raw,
                        std::uint8_t len,
                        bool wb_valid,
                        std::uint32_t wb_rd,
                        std::uint64_t wb_data,
                        bool mem_valid,
                        bool mem_is_store,
                        std::uint64_t mem_addr,
                        std::uint64_t mem_wdata,
                        std::uint64_t mem_rdata,
                        std::uint64_t mem_size,
                        bool trap_valid,
                        std::uint32_t trap_cause,
                        std::uint64_t next_pc) {
    if (!commit_trace.is_open() || !valid)
      return;
    const std::uint64_t insn = maskInsn(insn_raw, len);
    commit_trace << "{"
                 << "\"cycle\":" << commit_idx++ << ","
                 << "\"pc\":" << pc << ","
                 << "\"insn\":" << insn << ","
                 << "\"len\":" << static_cast<unsigned>(len) << ","
                 << "\"wb_valid\":" << (wb_valid ? 1 : 0) << ","
                 << "\"wb_rd\":" << wb_rd << ","
                 << "\"wb_data\":" << wb_data << ","
                 << "\"mem_valid\":" << (mem_valid ? 1 : 0) << ","
                 << "\"mem_is_store\":" << (mem_is_store ? 1 : 0) << ","
                 << "\"mem_addr\":" << mem_addr << ","
                 << "\"mem_wdata\":" << mem_wdata << ","
                 << "\"mem_rdata\":" << mem_rdata << ","
                 << "\"mem_size\":" << mem_size << ","
                 << "\"trap_valid\":" << (trap_valid ? 1 : 0) << ","
                 << "\"trap_cause\":" << trap_cause << ","
                 << "\"traparg0\":0,"
                 << "\"next_pc\":" << next_pc
                 << "}\n";
  };

  tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
  tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

  pyc::cpp::KonataWriter konata{};
  if (trace_konata) {
    std::uint64_t start = dut.cycles.value();
    if (!konata.open(out_dir / (std::string("tb_janus_bcc_ooo_pyc_cpp_") + name + ".konata"), start)) {
      std::cerr << "WARN: failed to open konata trace output under " << out_dir << "\n";
    }
  }

  std::uint64_t commitCount = 0;
  std::uint64_t issueCount = 0;
  std::uint64_t dispatchCount = 0;

  std::uint64_t maxCycles = kDefaultMaxCycles;
  if (const char *env = std::getenv("PYC_MAX_CYCLES")) {
    maxCycles = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }
  std::optional<std::uint64_t> expectedExitPc{};
  if (const char *env = std::getenv("PYC_EXPECT_EXIT_PC")) {
    expectedExitPc = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }
  std::uint64_t exitPcStable = 0;

  enum class PvStage : std::uint8_t { IQ, ROB };
  struct PvEntry {
    std::uint64_t id = 0;
    PvStage stage = PvStage::IQ;
    int lane = 0;
  };
  std::unordered_map<std::uint64_t, PvEntry> pvByRob{};
  std::uint64_t pvNextId = 1;

  auto pvStageName = [](PvStage s) -> const char * { return (s == PvStage::IQ) ? "S2" : "ROB"; };

  auto pvAlloc = [&](std::uint64_t pc, std::uint64_t op, std::uint64_t robIdx, int slot) {
    const std::uint64_t id = pvNextId++;
    pvByRob[robIdx] = PvEntry{.id = id, .stage = PvStage::IQ, .lane = slot};
    if (!konata.isOpen())
      return;
    konata.insn(/*fileId=*/id, /*simId=*/pc, /*threadId=*/0);
    std::ostringstream ss;
    ss << "pc=0x" << std::hex << pc << " op=" << std::dec << op << " rob=" << robIdx << " slot=" << slot;
    konata.label(id, /*type=*/0, ss.str());
    // Janus BCC OOO stages from designs/janus/PLAN.md:
    // - IFU: F0..F4 (bring-up currently models a single-entry F4 bundle)
    // - OOO: D1/D2/D3 (decode/uop/rename) then S2 (issue queue)
    //
    // For pipeview, dispatch_fire* is the first fully-observable per-uop event,
    // so we attribute the decode/rename work to this cycle and then keep the
    // uop resident in S2 until issue_fire*.
    konata.stageStart(id, /*laneId=*/slot, "F4");
    konata.stageEnd(id, /*laneId=*/slot, "F4");
    konata.stageStart(id, /*laneId=*/slot, "D1");
    konata.stageEnd(id, /*laneId=*/slot, "D1");
    konata.stageStart(id, /*laneId=*/slot, "D2");
    konata.stageEnd(id, /*laneId=*/slot, "D2");
    konata.stageStart(id, /*laneId=*/slot, "D3");
    konata.stageEnd(id, /*laneId=*/slot, "D3");
    konata.stageStart(id, /*laneId=*/slot, "S2");
  };

  auto pvSquash = [&](std::uint64_t robIdx) {
    auto it = pvByRob.find(robIdx);
    if (it == pvByRob.end())
      return;
    const std::uint64_t id = it->second.id;
    const int lane = it->second.lane;
    if (konata.isOpen()) {
      konata.stageEnd(id, /*laneId=*/lane, pvStageName(it->second.stage));
      konata.label(id, /*type=*/1, "squash");
      konata.retire(id, /*retireId=*/id, /*type=*/1);
    }
    pvByRob.erase(it);
  };

  bool done = false;
  for (std::uint64_t i = 0; i < maxCycles; i++) {
    if (konata.isOpen())
      konata.atCycle(dut.cycles.value());

    if (konata.isOpen() && !dut.halted.toBool()) {
      // Dispatch slots: allocate new Konata "instructions" keyed by ROB index.
      for (int slot = 0; slot < 4; slot++) {
        bool fire = false;
        std::uint64_t pc = 0;
        std::uint64_t op = 0;
        std::uint64_t robIdx = 0;
        if (slot == 0) {
          fire = dut.dispatch_fire0.toBool();
          pc = dut.dispatch_pc0.value();
          op = dut.dispatch_op0.value();
          robIdx = dut.dispatch_rob0.value();
        } else if (slot == 1) {
          fire = dut.dispatch_fire1.toBool();
          pc = dut.dispatch_pc1.value();
          op = dut.dispatch_op1.value();
          robIdx = dut.dispatch_rob1.value();
        } else if (slot == 2) {
          fire = dut.dispatch_fire2.toBool();
          pc = dut.dispatch_pc2.value();
          op = dut.dispatch_op2.value();
          robIdx = dut.dispatch_rob2.value();
        } else if (slot == 3) {
          fire = dut.dispatch_fire3.toBool();
          pc = dut.dispatch_pc3.value();
          op = dut.dispatch_op3.value();
          robIdx = dut.dispatch_rob3.value();
        }
        if (!fire)
          continue;
        pvSquash(robIdx);
        pvAlloc(pc, op, robIdx, /*slot=*/slot);
      }

      // Issue slots: transition IQ -> ROB based on issued ROB id.
      for (int slot = 0; slot < 4; slot++) {
        bool fire = false;
        std::uint64_t pc = 0;
        std::uint64_t op = 0;
        std::uint64_t robIdx = 0;
        if (slot == 0) {
          fire = dut.issue_fire0.toBool();
          pc = dut.issue_pc0.value();
          op = dut.issue_op0.value();
          robIdx = dut.issue_rob0.value();
        } else if (slot == 1) {
          fire = dut.issue_fire1.toBool();
          pc = dut.issue_pc1.value();
          op = dut.issue_op1.value();
          robIdx = dut.issue_rob1.value();
        } else if (slot == 2) {
          fire = dut.issue_fire2.toBool();
          pc = dut.issue_pc2.value();
          op = dut.issue_op2.value();
          robIdx = dut.issue_rob2.value();
        } else if (slot == 3) {
          fire = dut.issue_fire3.toBool();
          pc = dut.issue_pc3.value();
          op = dut.issue_op3.value();
          robIdx = dut.issue_rob3.value();
        }
        if (!fire)
          continue;
        auto it = pvByRob.find(robIdx);
        if (it == pvByRob.end())
          continue;
        if (it->second.stage != PvStage::IQ)
          continue;
        const std::uint64_t id = it->second.id;
        const int lane = it->second.lane;
        konata.stageEnd(id, /*laneId=*/lane, "S2");
        konata.stageStart(id, /*laneId=*/lane, "ROB");
        it->second.stage = PvStage::ROB;
        std::ostringstream ss;
        ss << "issue pc=0x" << std::hex << pc << " op=" << std::dec << op << " slot=" << slot;
        konata.label(id, /*type=*/1, ss.str());
      }

      // Commit slots: retire (stage end + R).
      for (int slot = 0; slot < 4; slot++) {
        bool fire = false;
        std::uint64_t pc = 0;
        std::uint64_t op = 0;
        std::uint64_t robIdx = 0;
        if (slot == 0) {
          fire = dut.commit_fire0.toBool();
          pc = dut.commit_pc0.value();
          op = dut.commit_op0.value();
          robIdx = dut.commit_rob0.value();
        } else if (slot == 1) {
          fire = dut.commit_fire1.toBool();
          pc = dut.commit_pc1.value();
          op = dut.commit_op1.value();
          robIdx = dut.commit_rob1.value();
        } else if (slot == 2) {
          fire = dut.commit_fire2.toBool();
          pc = dut.commit_pc2.value();
          op = dut.commit_op2.value();
          robIdx = dut.commit_rob2.value();
        } else if (slot == 3) {
          fire = dut.commit_fire3.toBool();
          pc = dut.commit_pc3.value();
          op = dut.commit_op3.value();
          robIdx = dut.commit_rob3.value();
        }
        if (!fire)
          continue;
        auto it = pvByRob.find(robIdx);
        if (it == pvByRob.end())
          continue;
        const std::uint64_t id = it->second.id;
        const int lane = it->second.lane;
        konata.stageEnd(id, /*laneId=*/lane, pvStageName(it->second.stage));
        std::ostringstream ss;
        ss << "commit pc=0x" << std::hex << pc << " op=" << std::dec << op << " slot=" << slot;
        konata.label(id, /*type=*/1, ss.str());
        konata.retire(id, /*retireId=*/id, /*type=*/0);
        pvByRob.erase(it);
      }
    }

    for (int slot = 0; slot < 4; slot++) {
      bool fire = false;
      std::uint64_t pc = 0;
      std::uint64_t insnRaw = 0;
      std::uint8_t len = 0;
      bool wbValid = false;
      std::uint32_t wbRd = 0;
      std::uint64_t wbData = 0;
      bool memValid = false;
      bool memIsStore = false;
      std::uint64_t memAddr = 0;
      std::uint64_t memWdata = 0;
      std::uint64_t memRdata = 0;
      std::uint64_t memSize = 0;
      bool trapValid = false;
      std::uint32_t trapCause = 0;
      std::uint64_t nextPc = 0;
      if (slot == 0) {
        fire = dut.commit_fire0.toBool();
        pc = dut.commit_pc0.value();
        insnRaw = dut.commit_insn_raw0.value();
        len = static_cast<std::uint8_t>(dut.commit_len0.value() & 0x7u);
        wbValid = dut.commit_wb_valid0.toBool();
        wbRd = static_cast<std::uint32_t>(dut.commit_wb_rd0.value());
        wbData = dut.commit_wb_data0.value();
        memValid = dut.commit_mem_valid0.toBool();
        memIsStore = dut.commit_mem_is_store0.toBool();
        memAddr = dut.commit_mem_addr0.value();
        memWdata = dut.commit_mem_wdata0.value();
        memRdata = dut.commit_mem_rdata0.value();
        memSize = dut.commit_mem_size0.value();
        trapValid = dut.commit_trap_valid0.toBool();
        trapCause = static_cast<std::uint32_t>(dut.commit_trap_cause0.value());
        nextPc = dut.commit_next_pc0.value();
      } else if (slot == 1) {
        fire = dut.commit_fire1.toBool();
        pc = dut.commit_pc1.value();
        insnRaw = dut.commit_insn_raw1.value();
        len = static_cast<std::uint8_t>(dut.commit_len1.value() & 0x7u);
        wbValid = dut.commit_wb_valid1.toBool();
        wbRd = static_cast<std::uint32_t>(dut.commit_wb_rd1.value());
        wbData = dut.commit_wb_data1.value();
        memValid = dut.commit_mem_valid1.toBool();
        memIsStore = dut.commit_mem_is_store1.toBool();
        memAddr = dut.commit_mem_addr1.value();
        memWdata = dut.commit_mem_wdata1.value();
        memRdata = dut.commit_mem_rdata1.value();
        memSize = dut.commit_mem_size1.value();
        trapValid = dut.commit_trap_valid1.toBool();
        trapCause = static_cast<std::uint32_t>(dut.commit_trap_cause1.value());
        nextPc = dut.commit_next_pc1.value();
      } else if (slot == 2) {
        fire = dut.commit_fire2.toBool();
        pc = dut.commit_pc2.value();
        insnRaw = dut.commit_insn_raw2.value();
        len = static_cast<std::uint8_t>(dut.commit_len2.value() & 0x7u);
        wbValid = dut.commit_wb_valid2.toBool();
        wbRd = static_cast<std::uint32_t>(dut.commit_wb_rd2.value());
        wbData = dut.commit_wb_data2.value();
        memValid = dut.commit_mem_valid2.toBool();
        memIsStore = dut.commit_mem_is_store2.toBool();
        memAddr = dut.commit_mem_addr2.value();
        memWdata = dut.commit_mem_wdata2.value();
        memRdata = dut.commit_mem_rdata2.value();
        memSize = dut.commit_mem_size2.value();
        trapValid = dut.commit_trap_valid2.toBool();
        trapCause = static_cast<std::uint32_t>(dut.commit_trap_cause2.value());
        nextPc = dut.commit_next_pc2.value();
      } else if (slot == 3) {
        fire = dut.commit_fire3.toBool();
        pc = dut.commit_pc3.value();
        insnRaw = dut.commit_insn_raw3.value();
        len = static_cast<std::uint8_t>(dut.commit_len3.value() & 0x7u);
        wbValid = dut.commit_wb_valid3.toBool();
        wbRd = static_cast<std::uint32_t>(dut.commit_wb_rd3.value());
        wbData = dut.commit_wb_data3.value();
        memValid = dut.commit_mem_valid3.toBool();
        memIsStore = dut.commit_mem_is_store3.toBool();
        memAddr = dut.commit_mem_addr3.value();
        memWdata = dut.commit_mem_wdata3.value();
        memRdata = dut.commit_mem_rdata3.value();
        memSize = dut.commit_mem_size3.value();
        trapValid = dut.commit_trap_valid3.toBool();
        trapCause = static_cast<std::uint32_t>(dut.commit_trap_cause3.value());
        nextPc = dut.commit_next_pc3.value();
      }
      emitCommit(fire, pc, insnRaw, len, wbValid, wbRd, wbData, memValid, memIsStore, memAddr, memWdata, memRdata, memSize, trapValid, trapCause,
                 nextPc);
    }

    if (dut.mmio_uart_valid.toBool() && !dut.halted.toBool()) {
      const char ch = static_cast<char>(dut.mmio_uart_data.value() & 0xFFu);
      std::cout << ch << std::flush;
    }
    if (trace_verbose && dut.dispatch_fire.toBool() && !dut.halted.toBool()) {
      dispatchCount++;
      tb.log() << "[disp #" << std::dec << dispatchCount << "] fpc=0x" << std::hex << dut.fpc.value() << " dec_op=" << std::dec << dut.dec_op.value()
               << "\n";
    }
    if (trace_verbose && dut.issue_fire.toBool() && !dut.halted.toBool()) {
      issueCount++;
      tb.log() << "[issue #" << std::dec << issueCount << "] pc=0x" << std::hex << dut.issue_pc.value() << " op=" << std::dec << dut.issue_op.value()
               << " rob=" << dut.issue_rob.value() << " sl=" << dut.issue_sl.value() << " sr=" << dut.issue_sr.value() << " sp=" << dut.issue_sp.value()
               << " pdst=" << dut.issue_pdst.value() << " slv=0x" << std::hex << dut.issue_sl_val.value() << " srv=0x" << dut.issue_sr_val.value()
               << " spv=0x" << dut.issue_sp_val.value() << std::dec << " is_load=" << dut.issue_is_load.value() << " is_store=" << dut.issue_is_store.value()
               << " store_pending=" << dut.store_pending.value() << " store_pending_older=" << dut.store_pending_older.value() << " mem_raddr=0x" << std::hex
               << dut.mem_raddr.value() << std::dec << "\n";
    }
    if (trace_log && dut.commit_fire.toBool() && !dut.halted.toBool()) {
      commitCount++;
      tb.log() << "[commit #" << std::dec << commitCount << "] pc=0x" << std::hex << dut.pc.value() << " op=" << std::dec << dut.commit_op.value()
               << " val=0x" << std::hex << dut.commit_value.value() << std::dec << " dstk=" << dut.commit_dst_kind.value()
               << " areg=" << dut.commit_dst_areg.value() << " pdst=" << dut.commit_pdst.value() << " a0=0x" << std::hex << dut.a0.value()
               << " ct0=0x" << dut.ct0.value() << " cu0=0x" << dut.cu0.value() << " st0=0x" << dut.st0.value() << " su0=0x" << dut.su0.value()
               << " sp=0x" << dut.sp.value() << std::dec << " rob_count=" << dut.rob_count.value() << "\n";
    }
    tb.runCyclesAuto(1);
    if (dut.halted.toBool()) {
      done = true;
      break;
    }
    if (expectedExitPc.has_value() && dut.pc.value() == *expectedExitPc && dut.fpc.value() == *expectedExitPc) {
      exitPcStable++;
      if (exitPcStable >= kExitPcStableCycles) {
        done = true;
        break;
      }
    } else {
      exitPcStable = 0;
    }
  }
  if (konata.isOpen()) {
    // Ensure the Konata log is structurally balanced for viewers that require
    // every stage-start to have a matching end before EOF.
    for (const auto &kv : pvByRob) {
      const std::uint64_t id = kv.second.id;
      const int lane = kv.second.lane;
      konata.stageEnd(id, /*laneId=*/lane, pvStageName(kv.second.stage));
      konata.label(id, /*type=*/1, "end_of_sim");
      konata.retire(id, /*retireId=*/id, /*type=*/1);
    }
    pvByRob.clear();
  }
  if (!done) {
    std::cerr << "FAIL " << name << ": did not halt (pc=0x" << std::hex << dut.pc.value() << " fpc=0x" << dut.fpc.value() << ")\n";
    return false;
  }

  if (dut.mmio_exit_valid.toBool()) {
    std::cerr << "[janus-exit] code=" << std::dec << dut.mmio_exit_code.value() << "\n";
  }

  if (expectedA0.has_value()) {
    std::uint64_t got = dut.a0.value();
    if (got != *expectedA0) {
      std::cerr << "FAIL " << name << ": a0=0x" << std::hex << got << " expected 0x" << *expectedA0 << std::dec << "\n";
      return false;
    }
  }

  std::uint32_t got = dut.mem.peek32(0x100);
  if (expectedMem100.has_value()) {
    if (got != *expectedMem100) {
      std::cerr << "FAIL " << name << ": mem[0x100]=0x" << std::hex << got << " expected 0x" << *expectedMem100 << std::dec << "\n";
      return false;
    }
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << ")\n";
  } else {
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << " mem[0x100]=0x" << std::hex << got << std::dec << ")\n";
  }
  return true;
}

} // namespace

int main(int argc, char **argv) {
  bool perfMode = (std::getenv("PYC_PERF_REPEAT") != nullptr);
  std::optional<std::uint64_t> bootPcCli{};
  std::optional<std::uint64_t> perfRepeatCli{};
  std::optional<std::uint64_t> perfMaxCyclesCli{};
  const char *perfMemhCli = nullptr;
  std::vector<const char *> positionalArgs{};
  positionalArgs.reserve(static_cast<std::size_t>(argc > 1 ? argc - 1 : 0));

  auto printUsage = [&](const char *prog) {
    std::cerr << "Usage:\n"
              << "  " << prog << " [memh [expected_mem100 [expected_a0]]]\n"
              << "  " << prog << " --perf [--perf-repeat N] [--perf-max-cycles N] [--perf-memh PATH] [--boot-pc ADDR]\n";
  };

  for (int i = 1; i < argc; i++) {
    const std::string arg = argv[i];
    if (arg == "-h" || arg == "--help") {
      printUsage(argv[0]);
      return 0;
    }
    if (arg == "--perf") {
      perfMode = true;
      continue;
    }
    if (arg == "--boot-pc") {
      if (i + 1 >= argc) {
        std::cerr << "error: missing value for --boot-pc\n";
        return 2;
      }
      bootPcCli = static_cast<std::uint64_t>(std::stoull(argv[++i], nullptr, 0));
      continue;
    }
    if (arg == "--perf-repeat") {
      if (i + 1 >= argc) {
        std::cerr << "error: missing value for --perf-repeat\n";
        return 2;
      }
      perfMode = true;
      perfRepeatCli = static_cast<std::uint64_t>(std::stoull(argv[++i], nullptr, 0));
      continue;
    }
    if (arg == "--perf-max-cycles") {
      if (i + 1 >= argc) {
        std::cerr << "error: missing value for --perf-max-cycles\n";
        return 2;
      }
      perfMode = true;
      perfMaxCyclesCli = static_cast<std::uint64_t>(std::stoull(argv[++i], nullptr, 0));
      continue;
    }
    if (arg == "--perf-memh") {
      if (i + 1 >= argc) {
        std::cerr << "error: missing value for --perf-memh\n";
        return 2;
      }
      perfMode = true;
      perfMemhCli = argv[++i];
      continue;
    }
    if (!arg.empty() && arg[0] == '-') {
      std::cerr << "error: unknown option: " << arg << "\n";
      printUsage(argv[0]);
      return 2;
    }
    positionalArgs.push_back(argv[i]);
  }

  std::uint64_t bootPc = bootPcCli.value_or(kBootPc);
  if (!bootPcCli.has_value()) {
    if (const char *env = std::getenv("PYC_BOOT_PC")) {
      bootPc = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
    }
  }

  if (perfMode) {
    std::uint64_t repeats = perfRepeatCli.value_or(16);
    if (!perfRepeatCli.has_value()) {
      if (const char *env = std::getenv("PYC_PERF_REPEAT")) {
        repeats = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
      }
    }
    std::uint64_t maxCyclesPerRun = perfMaxCyclesCli.value_or(4096);
    if (!perfMaxCyclesCli.has_value()) {
      if (const char *env = std::getenv("PYC_PERF_MAX_CYCLES")) {
        maxCyclesPerRun = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
      }
    }
    const char *perfMemh = perfMemhCli;
    if ((!perfMemh || perfMemh[0] == '\0') && !positionalArgs.empty()) {
      perfMemh = positionalArgs[0];
    }
    if (!perfMemh || perfMemh[0] == '\0') {
      perfMemh = std::getenv("PYC_PERF_MEMH");
    }
    if (!perfMemh || perfMemh[0] == '\0') {
      perfMemh = "designs/janus/programs/test_or.memh";
    }
    return runPerfBenchmark(perfMemh, bootPc, repeats, maxCyclesPerRun) ? 0 : 1;
  }

  if (!positionalArgs.empty()) {
    if (positionalArgs.size() > 3u) {
      std::cerr << "error: too many positional arguments\n";
      printUsage(argv[0]);
      return 2;
    }
    const char *memh = positionalArgs[0];
    std::optional<std::uint32_t> expectedMem100{};
    std::optional<std::uint64_t> expectedA0{};
    if (positionalArgs.size() >= 2u)
      expectedMem100 = static_cast<std::uint32_t>(std::stoul(positionalArgs[1], nullptr, 0));
    if (positionalArgs.size() >= 3u)
      expectedA0 = static_cast<std::uint64_t>(std::stoull(positionalArgs[2], nullptr, 0));
    return runProgram("program", memh, bootPc, expectedMem100, expectedA0) ? 0 : 1;
  }

  // Default regression tests (memh fixtures checked into this repo).
  if (!runProgram("test_csel_fixed", "designs/janus/programs/test_csel_fixed.memh", kBootPc, /*expectedMem100=*/100u, /*expectedA0=*/{}))
    return 1;
  if (!runProgram("test_or", "designs/janus/programs/test_or.memh", kBootPc, /*expectedMem100=*/0x0000FF00u, /*expectedA0=*/{}))
    return 1;
  if (!runProgram("test_store100_llvm", "designs/janus/programs/test_store100_llvm.memh", kBootPc, /*expectedMem100=*/100u, /*expectedA0=*/{}))
    return 1;

  if (!runProgram("test_branch2", "designs/janus/programs/test_branch2.memh", /*bootPc=*/kBootPc + 0x0a, /*expectedMem100=*/{}, /*expectedA0=*/8u))
    return 1;
  if (!runProgram("test_call_simple", "designs/janus/programs/test_call_simple.memh", /*bootPc=*/kBootPc + 0x1c, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_jump", "designs/janus/programs/test_jump.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_pcrel", "designs/janus/programs/test_pcrel.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/43u))
    return 1;
  return 0;
}
