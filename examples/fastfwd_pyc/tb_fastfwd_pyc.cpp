#include <cstdint>
#include <cstdlib>
#include <deque>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>
#include <vector>

#include <pyc/cpp/pyc_print.hpp>
#include <pyc/cpp/pyc_tb.hpp>

// Generated by `pyc-compile --emit=cpp`.
#include "fastfwd_pyc_gen.hpp"

using pyc::cpp::Testbench;
using pyc::cpp::Wire;

namespace {

constexpr int kEngPerLane = 2; // Must match examples/fastfwd_pyc/fastfwd_pyc.py default.
constexpr int kTotalEng = 4 * kEngPerLane;

static Wire<1> &lanePktInVld(pyc::gen::FastFwd &d, int lane) {
  switch (lane) {
  case 0:
    return d.lane0_pkt_in_vld;
  case 1:
    return d.lane1_pkt_in_vld;
  case 2:
    return d.lane2_pkt_in_vld;
  case 3:
    return d.lane3_pkt_in_vld;
  default:
    std::cerr << "ERROR: invalid lane index: " << lane << "\n";
    std::exit(2);
  }
}

static Wire<128> &lanePktInData(pyc::gen::FastFwd &d, int lane) {
  switch (lane) {
  case 0:
    return d.lane0_pkt_in_data;
  case 1:
    return d.lane1_pkt_in_data;
  case 2:
    return d.lane2_pkt_in_data;
  case 3:
    return d.lane3_pkt_in_data;
  default:
    std::cerr << "ERROR: invalid lane index: " << lane << "\n";
    std::exit(2);
  }
}

static Wire<5> &lanePktInCtrl(pyc::gen::FastFwd &d, int lane) {
  switch (lane) {
  case 0:
    return d.lane0_pkt_in_ctrl;
  case 1:
    return d.lane1_pkt_in_ctrl;
  case 2:
    return d.lane2_pkt_in_ctrl;
  case 3:
    return d.lane3_pkt_in_ctrl;
  default:
    std::cerr << "ERROR: invalid lane index: " << lane << "\n";
    std::exit(2);
  }
}

static Wire<1> &lanePktOutVld(pyc::gen::FastFwd &d, int lane) {
  switch (lane) {
  case 0:
    return d.lane0_pkt_out_vld;
  case 1:
    return d.lane1_pkt_out_vld;
  case 2:
    return d.lane2_pkt_out_vld;
  case 3:
    return d.lane3_pkt_out_vld;
  default:
    std::cerr << "ERROR: invalid lane index: " << lane << "\n";
    std::exit(2);
  }
}

static Wire<128> &lanePktOutData(pyc::gen::FastFwd &d, int lane) {
  switch (lane) {
  case 0:
    return d.lane0_pkt_out_data;
  case 1:
    return d.lane1_pkt_out_data;
  case 2:
    return d.lane2_pkt_out_data;
  case 3:
    return d.lane3_pkt_out_data;
  default:
    std::cerr << "ERROR: invalid lane index: " << lane << "\n";
    std::exit(2);
  }
}

static Wire<1> &fwdPktVld(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwd0_pkt_data_vld;
  case 1:
    return d.fwd1_pkt_data_vld;
  case 2:
    return d.fwd2_pkt_data_vld;
  case 3:
    return d.fwd3_pkt_data_vld;
  case 4:
    return d.fwd4_pkt_data_vld;
  case 5:
    return d.fwd5_pkt_data_vld;
  case 6:
    return d.fwd6_pkt_data_vld;
  case 7:
    return d.fwd7_pkt_data_vld;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<128> &fwdPktData(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwd0_pkt_data;
  case 1:
    return d.fwd1_pkt_data;
  case 2:
    return d.fwd2_pkt_data;
  case 3:
    return d.fwd3_pkt_data;
  case 4:
    return d.fwd4_pkt_data;
  case 5:
    return d.fwd5_pkt_data;
  case 6:
    return d.fwd6_pkt_data;
  case 7:
    return d.fwd7_pkt_data;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<2> &fwdPktLat(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwd0_pkt_lat;
  case 1:
    return d.fwd1_pkt_lat;
  case 2:
    return d.fwd2_pkt_lat;
  case 3:
    return d.fwd3_pkt_lat;
  case 4:
    return d.fwd4_pkt_lat;
  case 5:
    return d.fwd5_pkt_lat;
  case 6:
    return d.fwd6_pkt_lat;
  case 7:
    return d.fwd7_pkt_lat;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<1> &fwdPktDpVld(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwd0_pkt_dp_vld;
  case 1:
    return d.fwd1_pkt_dp_vld;
  case 2:
    return d.fwd2_pkt_dp_vld;
  case 3:
    return d.fwd3_pkt_dp_vld;
  case 4:
    return d.fwd4_pkt_dp_vld;
  case 5:
    return d.fwd5_pkt_dp_vld;
  case 6:
    return d.fwd6_pkt_dp_vld;
  case 7:
    return d.fwd7_pkt_dp_vld;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<128> &fwdPktDpData(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwd0_pkt_dp_data;
  case 1:
    return d.fwd1_pkt_dp_data;
  case 2:
    return d.fwd2_pkt_dp_data;
  case 3:
    return d.fwd3_pkt_dp_data;
  case 4:
    return d.fwd4_pkt_dp_data;
  case 5:
    return d.fwd5_pkt_dp_data;
  case 6:
    return d.fwd6_pkt_dp_data;
  case 7:
    return d.fwd7_pkt_dp_data;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<1> &fwdedPktVld(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwded0_pkt_data_vld;
  case 1:
    return d.fwded1_pkt_data_vld;
  case 2:
    return d.fwded2_pkt_data_vld;
  case 3:
    return d.fwded3_pkt_data_vld;
  case 4:
    return d.fwded4_pkt_data_vld;
  case 5:
    return d.fwded5_pkt_data_vld;
  case 6:
    return d.fwded6_pkt_data_vld;
  case 7:
    return d.fwded7_pkt_data_vld;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

static Wire<128> &fwdedPktData(pyc::gen::FastFwd &d, int e) {
  switch (e) {
  case 0:
    return d.fwded0_pkt_data;
  case 1:
    return d.fwded1_pkt_data;
  case 2:
    return d.fwded2_pkt_data;
  case 3:
    return d.fwded3_pkt_data;
  case 4:
    return d.fwded4_pkt_data;
  case 5:
    return d.fwded5_pkt_data;
  case 6:
    return d.fwded6_pkt_data;
  case 7:
    return d.fwded7_pkt_data;
  default:
    std::cerr << "ERROR: invalid engine index: " << e << "\n";
    std::exit(2);
  }
}

class FeModel {
public:
  FeModel() = default;

  void driveDue(pyc::gen::FastFwd &dut, std::uint64_t cycle) {
    for (int e = 0; e < kTotalEng; e++) {
      fwdedPktVld(dut, e) = Wire<1>(0);
      fwdedPktData(dut, e) = Wire<128>(0);

      PendingSlot &s = pending_[e][cycle % kSlots];
      if (!s.valid || s.due_cycle != cycle)
        continue;
      fwdedPktVld(dut, e) = Wire<1>(1);
      fwdedPktData(dut, e) = s.data;
      s.valid = false;
    }
  }

  void captureAndSchedule(pyc::gen::FastFwd &dut, std::uint64_t cycle, std::ostream *log) {
    for (int e = 0; e < kTotalEng; e++) {
      if (!fwdPktVld(dut, e).toBool())
        continue;

      std::uint64_t lat = fwdPktLat(dut, e).value() & 0x3u;
      // The DUT schedules completions relative to TIME__cycle (pre-dispatch) as:
      //   due = cycle + 2 + lat
      // because the dispatch is captured on the next posedge.
      std::uint64_t due = cycle + 2u + lat;

      Wire<128> in = fwdPktData(dut, e);
      Wire<128> dp = fwdPktDpVld(dut, e).toBool() ? fwdPktDpData(dut, e) : Wire<128>(0);
      Wire<128> out = in + dp;

      // The design should guarantee no per-engine output collision.
      PendingSlot &s = pending_[e][due % kSlots];
      if (s.valid) {
        std::cerr << "ERROR: FE model collision on eng" << e << " due_cycle=" << due << " (slot already valid for due="
                  << s.due_cycle << ")\n";
        std::exit(2);
      }
      s.valid = true;
      s.due_cycle = due;
      s.data = out;

      if (log) {
        (*log) << "[fe.in] cyc=" << cycle << " eng=" << e << " lat=" << (lat + 1u) << " due=" << due
               << " dp=" << (fwdPktDpVld(dut, e).toBool() ? 1 : 0) << "\n";
      }
    }
  }

private:
  static constexpr std::uint64_t kSlots = 16;
  struct PendingSlot {
    bool valid = false;
    std::uint64_t due_cycle = 0;
    Wire<128> data{};
  };

  PendingSlot pending_[kTotalEng][kSlots]{};
};

static std::uint64_t parseU64(const char *s) { return static_cast<std::uint64_t>(std::stoull(std::string(s), nullptr, 0)); }

static int runFastFwd(std::uint64_t seed, std::uint64_t maxCycles, std::uint64_t maxPackets, double pMed, double pHeavy) {
  pyc::gen::FastFwd dut{};
  Testbench<pyc::gen::FastFwd> tb(dut);

  const bool trace_log = (std::getenv("PYC_TRACE") != nullptr);
  const bool trace_vcd = (std::getenv("PYC_VCD") != nullptr);
  if (trace_log || trace_vcd) {
    const char *trace_dir_env = std::getenv("PYC_TRACE_DIR");
    std::filesystem::path out_dir =
        trace_dir_env ? std::filesystem::path(trace_dir_env) : std::filesystem::path("examples/generated/fastfwd_pyc");
    std::filesystem::create_directories(out_dir);

    if (trace_log) {
      tb.enableLog((out_dir / "tb_fastfwd_pyc_cpp.log").string());
      tb.log() << "tb_fastfwd_pyc(C++): seed=" << seed << " maxCycles=" << maxCycles << " maxPackets=" << maxPackets
               << " pMed=" << pMed << " pHeavy=" << pHeavy << " engines=" << kTotalEng << "\n";
    }

    if (trace_vcd) {
      tb.enableVcd((out_dir / "tb_fastfwd_pyc_cpp.vcd").string(), /*top=*/"tb_fastfwd_pyc_cpp");
      tb.vcdTrace(dut.clk, "clk");
      tb.vcdTrace(dut.rst, "rst");
      tb.vcdTrace(dut.pkt_in_bkpr, "pkt_in_bkpr");
      tb.vcdTrace(dut.TIME__cycle, "cycle");
      tb.vcdTrace(dut.TIME__seq_alloc, "seq_alloc");
      tb.vcdTrace(dut.commit_lane, "commit_lane");
      for (int i = 0; i < 4; i++) {
        tb.vcdTrace(lanePktInVld(dut, i), "lane" + std::to_string(i) + "_pkt_in_vld");
        tb.vcdTrace(lanePktInCtrl(dut, i), "lane" + std::to_string(i) + "_pkt_in_ctrl");
        tb.vcdTrace(lanePktInData(dut, i), "lane" + std::to_string(i) + "_pkt_in_data");
        tb.vcdTrace(lanePktOutVld(dut, i), "lane" + std::to_string(i) + "_pkt_out_vld");
        tb.vcdTrace(lanePktOutData(dut, i), "lane" + std::to_string(i) + "_pkt_out_data");
      }
      for (int e = 0; e < kTotalEng; e++) {
        tb.vcdTrace(fwdPktVld(dut, e), "fwd" + std::to_string(e) + "_pkt_data_vld");
        tb.vcdTrace(fwdPktLat(dut, e), "fwd" + std::to_string(e) + "_pkt_lat");
        tb.vcdTrace(fwdPktDpVld(dut, e), "fwd" + std::to_string(e) + "_pkt_dp_vld");
        tb.vcdTrace(fwdedPktVld(dut, e), "fwded" + std::to_string(e) + "_pkt_data_vld");
      }
    }
  }

  tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
  tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

  FeModel fe;
  std::mt19937_64 rng(seed);

  std::bernoulli_distribution sendMed(pMed);
  std::bernoulli_distribution sendHeavy(pHeavy);
  std::uniform_int_distribution<std::uint64_t> latDist(0, 3);
  std::uniform_int_distribution<std::uint64_t> u64dist(0, ~std::uint64_t{0});

  struct ExpectedPkt {
    std::uint64_t seq = 0;
    Wire<128> data{};
  };

  std::deque<ExpectedPkt> expectedOut{};
  std::vector<Wire<128>> expectedBySeq{};
  expectedBySeq.reserve(static_cast<std::size_t>(maxPackets));

  std::uint64_t sent = 0;
  std::uint64_t got = 0;
  std::uint64_t bkprCycles = 0;
  int outPtr = 0; // Next expected output lane (cyclic lane0->lane3->lane0...)

  // Main loop: drive stimulus on the low phase, then take a posedge+negedge.
  std::uint64_t simCycle = 0;
  while (simCycle < maxCycles || !expectedOut.empty()) {
    std::uint64_t dutCycle = dut.TIME__cycle.value();
    const bool bkpr = dut.pkt_in_bkpr.toBool();
    if (bkpr)
      bkprCycles++;

    // Drive FE outputs for this cycle.
    fe.driveDue(dut, dutCycle);

    // Drive PKTIN for this cycle (only when not backpressured).
    for (int lane = 0; lane < 4; lane++) {
      lanePktInVld(dut, lane) = Wire<1>(0);
      lanePktInData(dut, lane) = Wire<128>(0);
      lanePktInCtrl(dut, lane) = Wire<5>(0);
    }

    if (!bkpr && simCycle < maxCycles && sent < maxPackets) {
      bool doSend[4]{};
      for (int lane = 0; lane < 4; lane++) {
        bool heavy = (simCycle >= (maxCycles / 2));
        doSend[lane] = heavy ? sendHeavy(rng) : sendMed(rng);
      }

      for (int lane = 0; lane < 4; lane++) {
        if (!doSend[lane] || sent >= maxPackets)
          continue;

        std::uint64_t seq = sent;
        std::uint64_t maxDep = (seq < 7) ? seq : 7;
        std::uint64_t dep = 0;
        if (maxDep != 0) {
          std::uint64_t total = 14u + maxDep;
          std::uint64_t r = u64dist(rng) % total;
          dep = (r < 14u) ? 0u : (r - 13u);
        }
        std::uint64_t lat = latDist(rng);
        std::uint64_t ctrl = (lat & 0x3u) | ((dep & 0x7u) << 2u);

        std::uint64_t lo = u64dist(rng);
        std::uint64_t hi = u64dist(rng);
        Wire<128> data({lo, hi});

        Wire<128> dp_data = (dep != 0) ? expectedBySeq[static_cast<std::size_t>(seq - dep)] : Wire<128>(0);
        Wire<128> fwded = data + dp_data;

        expectedBySeq.push_back(fwded);
        expectedOut.push_back(ExpectedPkt{seq, fwded});
        sent++;

        lanePktInVld(dut, lane) = Wire<1>(1);
        lanePktInData(dut, lane) = data;
        lanePktInCtrl(dut, lane) = Wire<5>(ctrl);

        if (trace_log) {
          tb.log() << "[in]  cyc=" << dutCycle << " lane=" << lane << " seq=" << seq << " lat=" << (lat + 1u)
                   << " dep=" << dep << "\n";
        }
      }
    }

    // Evaluate combinational logic, capture FE inputs, then step posedge.
    dut.eval();
    fe.captureAndSchedule(dut, dutCycle, trace_log ? &tb.log() : nullptr);
    tb.step(); // posedge

    // Sanity: the DUT should have allocated exactly `sent` sequence numbers so far.
    std::uint64_t dutSeqAlloc = dut.TIME__seq_alloc.value();
    if (dutSeqAlloc != sent) {
      std::cerr << "FAIL: seq_alloc mismatch at cyc=" << dutCycle << " dut.seq_alloc=" << dutSeqAlloc << " sent=" << sent
                << " (bkpr=" << (bkpr ? 1 : 0) << ")\n";
      return 1;
    }

    // Check outputs right after posedge updates.
    //
    // Output ordering requirement:
    // - The next expected packet appears on `outPtr` (cyclic lane pointer)
    // - Up to 4 packets can be output in one cycle on consecutive lanes
    // - After an empty lane, the remaining lanes in the cycle must be empty
    int ptr = outPtr;
    int produced = 0;
    for (; produced < 4; produced++) {
      if (!lanePktOutVld(dut, ptr).toBool())
        break;

      if (expectedOut.empty()) {
        std::cerr << "FAIL: unexpected output (queue empty) at cyc=" << dutCycle << " lane=" << ptr << "\n";
        return 1;
      }
      ExpectedPkt exp = expectedOut.front();
      expectedOut.pop_front();
      Wire<128> out = lanePktOutData(dut, ptr);
      if (out != exp.data) {
        std::int64_t foundSeq = -1;
        for (std::size_t i = 0; i < expectedBySeq.size(); i++) {
          if (expectedBySeq[i] == out) {
            foundSeq = static_cast<std::int64_t>(i);
            break;
          }
        }
        std::cerr << "FAIL: data mismatch at cyc=" << dutCycle << " lane=" << ptr << " expected_seq=" << exp.seq
                  << " got=" << out << " exp=" << exp.data;
        if (foundSeq >= 0)
          std::cerr << " (got_seq=" << foundSeq << ")";
        std::cerr << " (sent=" << sent << " got=" << got << " outstanding=" << expectedOut.size()
                  << " tb.outPtr=" << outPtr << " dut.commit_lane=" << dut.commit_lane.value() << " exp_seq={"
                  << dut.lane0__exp_seq.value() << "," << dut.lane1__exp_seq.value() << "," << dut.lane2__exp_seq.value()
                  << "," << dut.lane3__exp_seq.value() << "})\n";
        return 1;
      }
      got++;
      if (trace_log) {
        tb.log() << "[out] cyc=" << dutCycle << " lane=" << ptr << " seq=" << exp.seq << " got=" << got
                 << " outstanding=" << expectedOut.size() << "\n";
      }
      ptr = (ptr + 1) & 3;
    }

    // Verify no "holes" after the first empty lane, in rotated order.
    for (int k = produced; k < 4; k++) {
      int lane = (outPtr + k) & 3;
      if (lanePktOutVld(dut, lane).toBool()) {
        std::cerr << "FAIL: output hole at cyc=" << dutCycle << " outPtr=" << outPtr << " saw empty then valid on lane=" << lane
                  << "\n";
        return 1;
      }
    }

    outPtr = ptr;
    if (static_cast<std::uint64_t>(outPtr) != (dut.commit_lane.value() & 0x3u)) {
      std::cerr << "FAIL: outPtr mismatch at cyc=" << dutCycle << " tb.outPtr=" << outPtr
                << " dut.commit_lane=" << dut.commit_lane.value() << "\n";
      return 1;
    }

    tb.step(); // negedge

    simCycle++;
    if (simCycle > (maxCycles + 20000) && !expectedOut.empty()) {
      std::cerr << "FAIL: timeout draining outstanding packets (outstanding=" << expectedOut.size() << ")\n";
      return 1;
    }
  }

  double throughput = (simCycle == 0) ? 0.0 : static_cast<double>(got) / static_cast<double>(simCycle);
  std::cout << "ok: FastFwd (engines=" << kTotalEng << " sent=" << sent << " got=" << got << " cycles=" << simCycle
            << " throughput=" << std::fixed << std::setprecision(3) << throughput << " pkt/cyc"
            << " bkpr=" << std::fixed << std::setprecision(2) << (100.0 * static_cast<double>(bkprCycles) / static_cast<double>(simCycle))
            << "%)\n";
  return 0;
}

} // namespace

int main(int argc, char **argv) {
  std::uint64_t seed = 1;
  std::uint64_t cycles = 20000;
  std::uint64_t packets = 60000;

  for (int i = 1; i < argc; i++) {
    std::string a(argv[i]);
    if (a == "--seed" && i + 1 < argc) {
      seed = parseU64(argv[++i]);
      continue;
    }
    if (a == "--cycles" && i + 1 < argc) {
      cycles = parseU64(argv[++i]);
      continue;
    }
    if (a == "--packets" && i + 1 < argc) {
      packets = parseU64(argv[++i]);
      continue;
    }
    if (a == "-h" || a == "--help") {
      std::cout << "Usage: " << argv[0] << " [--seed N] [--cycles N] [--packets N]\n";
      return 0;
    }
    std::cerr << "error: unknown arg: " << a << "\n";
    return 2;
  }

  // Match the published load: 41.7% then 90% (approx via per-lane Bernoulli).
  return runFastFwd(seed, cycles, packets, /*pMed=*/0.417, /*pHeavy=*/0.90);
}
